<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8">
<meta HTTP-EQUIV="Expires" CONTENT="-1" />
<meta HTTP-EQUIV="Pragma" CONTENT="no-cache" />
    
<style>
    html, body {
        margin: 0;
        padding: 10px 10px 10px 10px;
        width: 100%;
        height: 100%;
        overflow: hidden;
        box-sizing: border-box;
        background-color: darkblue;
    }
    #Container, video, img {
        position: absolute;
        z-index: 10;
        width: 100%;
        height: 100%;
    }
    img {
        object-fit: contain;
    }
    video.preroll {
        right: 0px;
        z-index: 11;
        width: 1px;
        height: 1px;
    }
    .hidden {
        position: inherit;
        z-index: inherit;
        visibility: hidden;
    }
    video::-internal-media-controls-overlay-cast-button {
        display: none;
    }
</style>
<script>
    class PreloadingVideo {
        url;
        videoE;

        constructor(cE, url) {
            this.url = url;
            this.videoE = document.createElement('video');
            this.videoE.classList.add('hidden');
            this.videoE.muted = true;
            this.videoE.autoplay = false;
            this.videoE.preload = 'auto';

            cE.append(this.videoE);
        }

        preload() {
            return new Promise((resolve, reject) => {
                this.videoE.onerror = reject;
                this.videoE.oncanplaythrough = () => {
                    this.videoE.oncanplaythrough = null;

                    resolve(this.videoE.duration);
                };

                this.videoE.src = this.url;
                this.videoE.load();
            });
        }
        play() {
            this.videoE.classList.remove('hidden');

            return new Promise(resolve => {
                this.videoE.onended = resolve;
                this.videoE.play().catch(err => reject(err));
            });
        }
        remove() {
            if (!this.videoE)
                return;

            this.videoE.onerror =
            this.videoE.oncanplaythrough =
            this.videoE.onended = null;

            this.videoE.remove();
            this.videoE = null;
        }
    }
    class GhostWorkaroundVideo {
        url;
        videoE;

        constructor(cE, url) {
            this.url = url;
            this.videoE = document.createElement('video');
            this.videoE.classList.add('hidden');
            this.videoE.muted = true;
            this.videoE.autoplay = false;
            this.videoE.preload = 'auto';

            cE.append(this.videoE);
        }

        preload() {
            return new Promise((resolve, reject) => {
                this.videoE.onerror = reject;
                this.videoE.oncanplaythrough = () => {
                    this.videoE.oncanplaythrough = null;

                    const timeUpdate = () => {
                        const skipFrameTime = 1.5 / 30;

                        const elapsed = this.videoE.currentTime;
                        if (this.videoE.currentTime < 1 / 25)
                            return;

                        this.videoE.removeEventListener('timeupdate', timeUpdate);
                        this.videoE.pause();
                        this.videoE.currentTime = skipFrameTime;
                        this.videoE.classList.remove('preroll');
                        this.videoE.classList.add('hidden');

                        resolve(this.videoE.duration - skipFrameTime);
                    }

                    this.videoE.addEventListener('timeupdate', timeUpdate);

                    this.videoE.classList.add('preroll');
                    this.videoE.classList.remove('hidden');
                    this.videoE.play();
                };

                this.videoE.src = this.url;
                this.videoE.load();
            });
        }
        play() {
            this.videoE.classList.remove('hidden');

            return new Promise(resolve => {
                this.videoE.onended = resolve;
                this.videoE.play().catch(err => reject(err));
            });
        }
        remove() {
            if (!this.videoE)
                return;

            this.videoE.onerror =
            this.videoE.oncanplaythrough =
            this.videoE.onended = null;

            this.videoE.remove();
            this.videoE = null;
        }
    }
    class Picture {
        imgE;
        url;
        duration;

        constructor(cE, url, duration) {
            this.url = url;
            this.duration = duration;
            this.imgE = document.createElement('img');
            this.imgE.classList.add('hidden');

            cE.append(this.imgE);
        }

        preload() {
            return new Promise(resolve => {
                this.imgE.onload = () => resolve(this.duration);
                this.imgE.src = this.url;
            });
        }

        play() {
            this.imgE.classList.remove('hidden');

            return new Promise(resolve => setTimeout(resolve, this.duration * 1000));
        }

        remove() {
            this.imgE.remove();
        }
    }

    const playlist = [
        (cE) => new GhostWorkaroundVideo(cE, "assets/Woods.mp4"),
        (cE) => new Picture(cE, "assets/Festus.jpg", 6),
        (cE) => new GhostWorkaroundVideo(cE, "https://signage.multiq.com/Loopback/previews/8648b14ba91b6842397a9bd9ca4ef470daf943ce/Adidas.mp4")
    ];
    
    async function start() {
        const cE = document.getElementById('Container');

        let idx = -1;
        let handler = playlist[++idx % playlist.length](cE);
        let duration = await handler.preload();

        while (true) {
            const ended = handler.play();

            await delay(duration * 1000 / 3);
            nextHandler = playlist[++idx % playlist.length](cE);
            duration = await nextHandler.preload();

            await ended;
            handler.remove();
            handler = nextHandler;
        }

        function delay(ms) {
            return (ms < 0
                ? Promise.resolve()
                : new Promise((resolve) => setTimeout(resolve, ms)));
        }
    }
</script>
</head>
<body onload="start()">
    <div id="Container"></div>
</body></html>
